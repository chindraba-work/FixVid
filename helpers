#!/bin/bash

# add new channel handler:
# -  create new command-stub (like extract-stereo or hts-downmix) to create a stereo stream
# -  add trap (possibly mapping, mixing, and layout) to helpers.surround_sound_settings
# -  add trap to stereo command calling the command-stub
# -  create new command(s) like hts-explode, hts-normalize, and hts-remix, to copy and normailze the stream
# -  add cammand-stub to include into video files

stack_num=0;
audio_codec_list='aac ac3 dts custom';

audio_key='stream';
audio_fields="source stream label title lang channels make_channels \
layout mapping mixing dyna_stereo dyna_center dyna_origin dyna_extras \
dyna_others make_ac3 include_ac3 make_aac include_aac make_dts \
include_dts codec filter complex ext make_custom include_custom \
include_original include_enhanced include_stereo include_channels";

subs_key='stream';
subs_fields="source stream file label lang title type included SDH";

video_key='codec';
video_fields="codec label params equalizer adjust complex";

# Create some text shortcuts and functions to use later.
#
# ffmpeg for ignoring all but the chosen type of stream
audio_only="-vn -sn -dn";
video_only="-an -sn -dn";
subtitles_only="-vn -an -dn";
# ffmpeg to ignore input timestamps, and force creation of new ones
input_flags="-fflags +igndts";
output_flags="-fflags +genpts";
# ffmpeg to leverage the multi-threading of the CPU, for aware libraries
use_threads="-threads 0";
# ffmpeg to strip the metadata from the input file, except chapter times
strip_meta_only="-map_metadata -1";
# ffmpeg to strip the metadata from the input file, including chapter times
strip_meta_all="-map_metadata -1 -map_chapters -1";
file_meta="-metadata creation_time=$timestamp \
-metadata language=$video_lang -metadata title='$video_title'"

function multi_launch {
# Function to utilize multiple cores better
# Sourced from an answer to "How do you run multiple programs in
# parallel from a bash script?" on Stack Overflow. See:
# https://stackoverflow.com/a/42098494/7412956
# From user https://stackoverflow.com/users/2615062
# All Stack Overflow contributions licensed under cc by-sa 3.0 with
# attribution required.
local ident=$1;
shift;
echo "Processing $ident ...";
"$@" && echo "... $ident complete" &
local my_pid=$$
# local parallels=$(pstree -p 1 | grep -o 'ffmpeg(' | wc -l)
local parallels=$(ps -eo ppid | grep -w $my_pid | wc -w)
parallels=$((parallels-1))
if [[ $parallels -ge $max_parallel ]]; then
    wait -n
fi
}

function load_limit {
  # Get the settings prefix to use
  load_prefix="$1";
  load_var="${load_prefix}_key";
  load_key="${!load_var}";
  load_limit=1;
  var="${load_prefix}_${load_key}_${load_limit}";
  while [[ ${!var} ]]; do
    ((load_limit++));
    var="${load_prefix}_${load_key}_${load_limit}";
  done;
  declare -g ${load_prefix}_limit=$load_limit;
}

function clear_group {
  # Get the settings prefix to use
  clear_prefix="$1";
  field_list="${clear_prefix}_fields";
  for field in ${!field_list}; do
    unset "${clear_prefix}_${field}";
  done
}

function load_group {
  # Get the settings prefix to use
  load_prefix="$1";
  clear_group $load_prefix;
  var="${load_prefix}_limit";
  load_limit=${!var};
  load_list="${load_prefix}_fields";
  # Get the settings group number to load
  [[ $2 ]] && load_target=$2 || load_target=1;
  [[ $load_target -lt $load_limit ]] || return 0;
  for field in ${!load_list}; do
    var="${load_prefix}_${field}_${load_target}";
    declare -g ${load_prefix}_${field}="${!var}";
  done
  # Check for source file and replace with common source if missing
  var="${load_prefix}_source";
  [[ ${!var} ]] || declare -g $var="$video_source";

  # Check for, and set the language of the stream
  var="${load_prefix}_lang";
  [[ ${!var} ]] || declare -g $var="$video_lang";

  # Check for, and set the label of the stream
  var="${load_prefix}_label";
  [[ ${!var} ]] || declare -g $var="${load_prefix}-${load_target}";

  # Add defaults for audio streams
  [[ 'audio' = $load_prefix ]] && {
    # To include either the original or the enhanced streams, there must
    # be at least one layout included. DTS, other surround sound, or
    # stereo. Stereo can be made from any source, so that is default
    [[ 1 -eq $audio_include_original ]] || \
    [[ 1 -eq $audio_include_enhanced ]] && \
    [[ 1 -ne $audio_include_dts ]] && \
    [[ 1 -ne $audio_include_channels ]] && \
      audio_include_stereo=1;

    # To include stereo or non-DTS surround sound, there must be at
    # at least one codec included as well. Defaults to AC3
    [[ 1 -eq $audio_include_stereo ]] || \
    [[ 1 -eq $audio_include_channels ]] && \
    [[ 1 -ne $audio_include_aac ]] && \
      audio_include_ac3=1;

    # Every codec that is included has to be made first
    for codec in $audio_codec_list; do
      var="${load_prefix}_include_${codec}";
      [[ 1 -eq ${!var} ]] && declare -g ${load_prefix}_make_${codec}=1;
    done

    # Check for, and set, default normalization values
    [[ $audio_dyna_center ]] || audio_dyna_center="$dyna_center";
    [[ $audio_dyna_extras ]] || audio_dyna_extras="$dyna_extras";
    [[ $audio_dyna_origin ]] || audio_dyna_origin="$dyna_origin";
    [[ $audio_dyna_stereo ]] || audio_dyna_stereo="$dyna_stereo";
    [[ $audio_dyna_others ]] || audio_dyna_others="$dyna_others";

    # Check for, and set default surround sound channel mapping values
    case $audio_channels in
      2 ) # Stereo is not surround sound
        ;;
      7.1 )
        [[ $audio_mapping ]] || audio_mapping="$audio_mapping_71"
        [[ $audio_layout ]]  || audio_layout="$audio_layout_71"
        [[ $audio_mixing ]]  || audio_mixing="$audio_mixing_71"
        ;;
      5.1 )
        [[ $audio_mapping ]] || audio_mapping="$audio_mapping_51"
        [[ $audio_layout ]]  || audio_layout="$audio_layout_51"
        [[ $audio_mixing ]]  || audio_mixing="$audio_mixing_51"
        ;;
      '5.1(side)' )
        [[ $audio_mapping ]] || audio_mapping="$audio_mapping_51_side"
        [[ $audio_layout ]]  || audio_layout="$audio_layout_51_side"
        [[ $audio_mixing ]]  || audio_mixing="$audio_mixing_51_side"
        ;;
      * )
        ;;
    esac
  }
}

function push_group {
  # Store the current prefix and target number, with group walking info
  [[ $current_prefix ]] && {
    (( stack_num++ ));
    declare -g stack_${stack_num}_prefix="$current_prefix";
    declare -g stack_${stack_num}_target="$current_target";
    declare -g stack_${stack_num}_all=$group_all;
    declare -g stack_${stack_num}_more=$group_continue;
    declare -g stack_${stack_num}_process=$item_process;
  }
  # Set the new prefix and target number and clear group walking data
  current_prefix="$1";
  current_target="$2";
  unset group_all;
  unset group_continue;
}

function pop_group {
  # Check for something to POP
  [[ 0 -lt $stack_num ]] || return 0;

  # Clear the current values
  unset current_prefix;
  unset current_target;
  unset group_all;
  unset group_continue;
  unset group_limit;
  unset item_process;
  # Restore the old values
  var="stack_${stack_num}_prefix";
  declare -g current_prefix="${!var}";
  var="stack_${stack_num}_target";
  declare -g current_target="${!var}";
  var="stack_${stack_num}_all";
  declare -g group_all="${!var}";
  var="stack_${stack_num}_more";
  declare -g group_continue="${!var}";
  var="stack_${stack_num}_process";
  declare -g item_process="${!var}";
  #load the group_limit
  var="${current_prefix}_limit";
  declare -g group_limit=${!var};
  (( stack_num-- ));
  # Reload the group data based on the restored prefix and target
  load_group "$current_prefix" $current_target;
}

function process_group {
# Function to determine which groups of settings are valid and which
# ones to process. Then process any of the fields that should be done
  group_prefix="$2";
  [[ $3 ]] && group_num=$3 || group_num=0;

  # Store previous target, if any
  push_group "$group_prefix" $group_num;

  item_process=$1; # The passed-in function to process the items with

  # Flag to process, or not, all setting groups
  [[ 0 -eq $current_target ]] && group_all=1 || unset group_all;

  #load the group_limit
  var="${current_prefix}_limit";
  group_limit=${!var};

  # Initialize the current_target, if needed
  [[ 0 -eq $current_target ]] && current_target=1;

  # Set the group_continue flag based on the validity of requested number
  [[ $current_target -lt $group_limit ]] && group_continue=1 || unset group_continue;

  while [[ 1 -eq $group_continue ]]; do
    # Load the group settings into the generic set of settings
    load_group "$current_prefix" $current_target;
    $item_process || return $x;
    (( current_target++ ));
    # Check for completion
    [[ 1 -eq $group_all ]] && [[ $current_target -lt $group_limit ]] && group_continue=1 || unset group_continue;
  done
  clear_group $current_prefix;
  pop_group;
  wait;
}

for prefix in audio subs video; do
  load_limit $prefix;
done




